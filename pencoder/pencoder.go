// pencoder contains encoders and decoders for byte slices.
package pencoder

type mode uint8

const (
	HexModeLower mode = iota
	HexModeUpper
)

const reverseHexTable = "" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\xff\xff\xff\xff\xff\xff" +
	"\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" +
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"

type HexEncoder struct {
	Mode mode
}

func (e HexEncoder) Decode(target, source []byte) int {
	if len(target) < len(source)/2 {
		panic("target buffer is too small")
	}

	i, j := 0, 0
	for ; j < len(source); j += 2 {
		hd := reverseHexTable[source[j]]
		tl := reverseHexTable[source[j+1]]

		target[i] = (hd << 4) | tl
		i++
	}

	return len(source) / 2
}

func (e HexEncoder) Encode(target, source []byte) int {
	if len(target) < len(source)*2 {
		panic("target buffer is too small")
	}

	byteEncoder := hexCharLower
	if e.Mode == HexModeUpper {
		byteEncoder = hexCharUpper
	}

	n := 0
	for _, b := range source {
		head := b >> 4
		tail := b & 0x0F

		target[n] = byteEncoder(head)
		target[n+1] = byteEncoder(tail)
		n += 2
	}

	return n
}

func hexCharUpper(b byte) byte {
	if b < 10 {
		return b + '0'
	}

	return b + 'A' - 10
}

func hexCharLower(b byte) byte {
	if b < 10 {
		return b + '0'
	}

	return b + 'a' - 10
}
